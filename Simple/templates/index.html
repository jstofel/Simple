{% extends "layout.html" %}
{% block body %}

<!--This is the template for page content. It has the following parameters:
pageresult:  a SQl Alxchemy ResultProxy object. This is the result of a sql
             query on the Page table, containing data that is 'like' the 
	     columns and rows of a table. See the manual for all methods to 
	     access data from this object. The specific methods used in this
	     template are:
	     1. fetchone() is used in the layout template to get the page title
	          from the first record in the object (the title of the index page)
		  and put it in the subheader. This method moves the cursor to the
		  next record, so the next method (the jinja for loop) starts there
	     2. for o in pageresult:  gets each remaining row in turn. Used to
	          display the list of the rest of the pages (after the index page).
	     3. rowcount: counts the number of rows in the object
	     See documentation for, say, the fetchone method, at 
http://docs.sqlalchemy.org/en/latest/core/connections.html?highlight=fetchone#sqlalchemy.engine.ResultProxy.fetchone
Note that the ResultProxy object "Wraps a DB-API cursor object to provide easier access to row columns."
and the methods are DBA-API cursor methods... They seem to only go forward, not backward on stay in place.
-->

<!--Show the Index Page: Where the User Has Not Yet Selected a Page-->
{% if pageresult.rowcount > 1 %}

 <div id="addPageSectionDiv" class=""  style='float:right; width:30%;'>
   <div style='float:right; width=90%'>
    <input type='button' id='showAddPage' value='Add Page' style='width:9rem' 
	   onClick="$('#addPageFormDiv').toggle(); $('#showAddPage').toggle()" >
   </div>

   <!-- Add a form to add a new page -->
   {% from "_formhelpers.html" import render_field %}

   <div id="addPageFormDiv" class="" style='float:right;width:90%; display:none' >
    <form id = "addPage" action="{{url_for('index')}}" method=POST>
       <div style='float:right'>  {{ form.submit }} </div>
       <br>
       <dl>
       {{ render_field(form.new_page_name) }} 
       {{ render_field(form.new_page_title) }}
       </dl>
    </form>
   </div>
 </div>

  <!-- Show ordered list of page names -->
  <!--p> There are {{pageresult.rowcount}} rows in the object. The first one was pulled off for the index title. </p-->
  <ol>
   {% for o in pageresult %}
    <li>  
     <a href="{{url_for('index')}}?page_id={{o[0]}}"> {{ o[1] }}  </a>
    </li>
   {% endfor %}
  </ol>


{% else %}

<!-- Show the Page the User Has Requested -->
<!-- Note: there are no longer any records in the pageresult cursor, as we have moved through them all and it has closed -->

<!--Put in a Markdown Editor to accept content-->
<!-- It has a Show/Hide Button, a Div with instructions, an Editor div that lets you write, and a Target div 
     that shows what you've written, all closed out by a div to clear the floats.
     The functionality of this Markdown editor comes from the ShowDown library
     at http://showdownjs.github.io/demo/ by John Fraser . Thanks! -->

<form id="editContentForm"
      action="{{url_for('index')}}"
      method="GET" >

<div id="BUTTONS" class=""  style='float:left; width:48%; height:3rem '>
<input type='button' id='showEditContent' value='Open Editor' style='width:9rem' >
<input type='submit' id='saveit' value='Save' style='display:none' >
<input type = "hidden" name="page_id" value="{{page_id}}" >
</div>

<div id="INSTRUCTIONS"  class="" style='float:left; width:40% ; height:3rem; display:none; '>
 Edit the content in the textarea below using markdown styling, and see how it renders on the left.
</div>

<div id="targetDiv" class=""  style='float:left; width:80%;'>{{content_html}}</div>

<div id="editorDiv"  class="" style='float:right;width:52%; display:none; '>
<textarea id="sourceTA" rows="40" cols="40"   onInput="runConverter()">{{content_markdown}}</textarea>
</div>

</form>

<div style='float:none'> </div>



<!-- Add JQ functionality to show/hide buttons for the Single Page controls-->
<script>
jQuery(document).ready(function(){

jQuery('#showEditContent').on('click', function(event) {
             $('#editorDiv').toggle();
             $('#INSTRUCTIONS').toggle();
             if ( $(this).val() == 'Close Editor' ) {
                 $(this).val('Open Editor');
                 $('#targetDiv').width('80%');
                 $('#saveit').hide()
             } else {
                 $(this).val('Close Editor');
                 $('#targetDiv').width('48%');
                 $('#saveit').show()
            }
        });
    });

  jQuery('#saveit').on('click', function(event) {
             //Put the code to write to db here
                /*This may require a redirect - or, the SAVE button
                   should be the forms SUBMIT button... and have to 
                   make sure that the targetDiv has a textarea in it
                   too (not editable by the user) .  Hm.... */

             //This refreshes the page with the same inputs as original
             // Interesting that it has a slight fade, not a pop...
               location.reload()


    });

   //Run the load conditions
   //The runConverter function takes the input conent, translates it, and writes it to the target div
   window.onload = function(){
     runConverter();
   }


</script>


{% endif %}





{% endblock %}
